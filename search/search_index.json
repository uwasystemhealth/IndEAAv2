{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IndEAA Technical Documentation \u00b6 This will contain the technical documentation used for IndEAA. For now, there wont'be any confidential information here. It will probably contain the following: - structure of the codebase - VPS setup / infrastructure - different components to running the application","title":"Overview"},{"location":"#indeaa-technical-documentation","text":"This will contain the technical documentation used for IndEAA. For now, there wont'be any confidential information here. It will probably contain the following: - structure of the codebase - VPS setup / infrastructure - different components to running the application","title":"IndEAA Technical Documentation"},{"location":"developer/","text":"Developer Documentation \u00b6 Execution \u00b6 Make sure you have docker installed. To start the application. Copy docker/indeaa-local.env to .env (in the root folder) run docker-compose up This command should setup the containers (it will take sometime if this is the first time you ran that command). Then you can start development. Google Authentication? You will need to create an OAuth 2.0 client in Google Cloud and provide the details in the .env file. See Authentication for more details","title":"Overview"},{"location":"developer/#developer-documentation","text":"","title":"Developer Documentation"},{"location":"developer/#execution","text":"Make sure you have docker installed. To start the application. Copy docker/indeaa-local.env to .env (in the root folder) run docker-compose up This command should setup the containers (it will take sometime if this is the first time you ran that command). Then you can start development. Google Authentication? You will need to create an OAuth 2.0 client in Google Cloud and provide the details in the .env file. See Authentication for more details","title":"Execution"},{"location":"developer/authentication/","text":"Authentication \u00b6 Frontend \u00b6 Login \u00b6 Reauthenticate with LocalStorage \u00b6 The token is stored in the localStorage. The user is reauthenticated everytime the application is loaded. The expiry of the token can be seen in base.py . When does the token expire? Let's say the expiry of the token lasts for 1 day. Because of the reauthentication everytime the application is loaded, as long as someone logs in before the token expires, the user will always get a fresh token. Authentication Context \u00b6 The authentication uses context to pass the user information across the different component. See components/context.tsx . Refer to React Context documentation for more information. Authentication Components \u00b6 The authentication feature has created multiple different component used in various places. AuthenticationGuard \u00b6 This component is used to check if the user is authenticated. If not, it redirects to the login page. Usage This component is just a wrapper around your component. 1 2 3 <AuthenticationGuard> <YourComponent /> </AuthenticationGuard> PermissionGuard \u00b6 This component is an extention of AuthenticationGuard and is used to check if the user has the permission to access the page. TODO Backend \u00b6 The backend authentication is handled by dj-rest-auth with a plugin called d jangorestframework-simplejwt (plugin reference link ). This is currently served at api/v1/authentication (see backend/config/urls.py::api_patterns ) Google OAuth setup \u00b6 Sign up for Google Cloud and create a new project from the console . On the side menu under \"APIs and services\" click \"Credentials\" At the top of the page click \"Create credentials\" and select \"OAuth client ID\" Now fill out the form with these values: Field Value Application Type Web Application Authorized Javascript origins <YOURDOMAIN>:8000 Authorized redirect URIs <YOURDOMAIN>:8000/api/v1/authentication/google/login/callback/ Replace <YOURDOMAIN> with your real domain, for example in testing it could be http://localhost Now that you have created the OAuth client, copy the Client ID and Client secret from the side. Paste these into your .env file with keys GOOGLE_CLIENT_ID and GOOGLE_SECRET While in development you will need to manually add users until Google approves your application. Click \"OAuth consent screen\" on the left. You can add up to 100 test users, which are the emails of Google accounts. OAuth process \u00b6 The user presses a button on the login page The user is directed to the endpoint /api/v1/authentication/google/login/redirect/ , which crafts a Google login page URL based on the application's Google client ID. https://accounts.google.com/o/oauth2/v2/auth?redirect_uri=DOMAIN/api/v1/authentication/google/login/callback/&prompt=consent&response_type=code&client_id={GOOGLE_CLIENT_ID}&scope={scope}{params} The user is redirected to the URL, then signs into their Google account on Google's login page. Google redirects the user to the callback_url which is an backend API endpoint on our server: /api/v1/authentication/google/login/callback/ . Google GET s this callback endpoint with data including a code. The callback endpoint redirects the user to a login page on the frontend. The code is then POST ed to /api/v1/authentication/google/ . The backend then logs the user into their account on our server. Links \u00b6 Google OAuth docs","title":"Authentication"},{"location":"developer/authentication/#authentication","text":"","title":"Authentication"},{"location":"developer/authentication/#frontend","text":"","title":"Frontend"},{"location":"developer/authentication/#login","text":"","title":"Login"},{"location":"developer/authentication/#reauthenticate-with-localstorage","text":"The token is stored in the localStorage. The user is reauthenticated everytime the application is loaded. The expiry of the token can be seen in base.py . When does the token expire? Let's say the expiry of the token lasts for 1 day. Because of the reauthentication everytime the application is loaded, as long as someone logs in before the token expires, the user will always get a fresh token.","title":"Reauthenticate with LocalStorage"},{"location":"developer/authentication/#authentication-context","text":"The authentication uses context to pass the user information across the different component. See components/context.tsx . Refer to React Context documentation for more information.","title":"Authentication Context"},{"location":"developer/authentication/#authentication-components","text":"The authentication feature has created multiple different component used in various places.","title":"Authentication Components"},{"location":"developer/authentication/#authenticationguard","text":"This component is used to check if the user is authenticated. If not, it redirects to the login page. Usage This component is just a wrapper around your component. 1 2 3 <AuthenticationGuard> <YourComponent /> </AuthenticationGuard>","title":"AuthenticationGuard"},{"location":"developer/authentication/#permissionguard","text":"This component is an extention of AuthenticationGuard and is used to check if the user has the permission to access the page. TODO","title":"PermissionGuard"},{"location":"developer/authentication/#backend","text":"The backend authentication is handled by dj-rest-auth with a plugin called d jangorestframework-simplejwt (plugin reference link ). This is currently served at api/v1/authentication (see backend/config/urls.py::api_patterns )","title":"Backend"},{"location":"developer/authentication/#google-oauth-setup","text":"Sign up for Google Cloud and create a new project from the console . On the side menu under \"APIs and services\" click \"Credentials\" At the top of the page click \"Create credentials\" and select \"OAuth client ID\" Now fill out the form with these values: Field Value Application Type Web Application Authorized Javascript origins <YOURDOMAIN>:8000 Authorized redirect URIs <YOURDOMAIN>:8000/api/v1/authentication/google/login/callback/ Replace <YOURDOMAIN> with your real domain, for example in testing it could be http://localhost Now that you have created the OAuth client, copy the Client ID and Client secret from the side. Paste these into your .env file with keys GOOGLE_CLIENT_ID and GOOGLE_SECRET While in development you will need to manually add users until Google approves your application. Click \"OAuth consent screen\" on the left. You can add up to 100 test users, which are the emails of Google accounts.","title":"Google OAuth setup"},{"location":"developer/authentication/#oauth-process","text":"The user presses a button on the login page The user is directed to the endpoint /api/v1/authentication/google/login/redirect/ , which crafts a Google login page URL based on the application's Google client ID. https://accounts.google.com/o/oauth2/v2/auth?redirect_uri=DOMAIN/api/v1/authentication/google/login/callback/&prompt=consent&response_type=code&client_id={GOOGLE_CLIENT_ID}&scope={scope}{params} The user is redirected to the URL, then signs into their Google account on Google's login page. Google redirects the user to the callback_url which is an backend API endpoint on our server: /api/v1/authentication/google/login/callback/ . Google GET s this callback endpoint with data including a code. The callback endpoint redirects the user to a login page on the frontend. The code is then POST ed to /api/v1/authentication/google/ . The backend then logs the user into their account on our server.","title":"OAuth process"},{"location":"developer/authentication/#links","text":"Google OAuth docs","title":"Links"},{"location":"developer/automated_testing_and_ci/","text":"Automated Testing and CI \u00b6 Automated testing help us to ensure that our code is working as expected. Continuous Integration (CI) is a process that helps us to ensure that our code is working as expected by running our automated testing on events such as pull requests and code commits. Automated Testing \u00b6 Backend: Pytest (Unit Testing) \u00b6 We use pytest for our tests with pytest-django as a plugin. Running Test \u00b6 Go inside the container docker exec -it indeaa_django bash or docker-compose exec -it backend bash Run pytest py.test or pytest . Manual Testing Debugging You can add breakpoint() in your code and attach a terminal to the instance docker attach indeaa_django . Running only a specific test If you only want to run a specific test, use the below syntax 1 2 3 py.test course_evaluations/ # Runs all test within the folder py.test course_evaluations/test_crud.py # Runs the test in the file py.test course_evaluations/test_crud.py::test_list_view_course_evaluation # Run the specific function you want Pytest Fixture conftest.py \u00b6 You will notice that the test will use conftest.py . The syntax is a little weird at first, the fixture becomes parameters in tests that needs it. Test that uses a conftest 1 2 3 4 5 def test_list_view_course_evaluation ( api_client_with_credentials_return_user , make_course_evaluation ): api_client , user = api_client_with_credentials_return_user () course_evaluation_1 = make_course_evaluation ( coordinators = [ user ]) course_evaluation_2 = make_course_evaluation ( coordinators = [ user ]) ... api_client_with_credentials_return_user and make_course_evaluation are function that can bhe seen in conftest.py . This is accessible because of the command called @pytest.fixture . Also notice function such as make_course_evaluation . It has an interesting structure where it does a yield _make_course_evaluation . We are essentially creating a wrapper function that allows us to bind the teardown with that function. Why not just use the default Django Tests? \u00b6 The pytest ecosystem is bigger. Harder to get used to at first, but it is quite worth it because you can do cool examples like parametrised tests (checkout this link) that are more readable and maintainable. Frontend: Cypress (E2E Testing) \u00b6 We use Cypress for E2E testing. Running the test. \u00b6 There are two ways to run the test. Firstly navigate to the frontend folder: Run tests via the the Cypress IDE: yarn cypress:open Run tests via the CLI: yarn cypress:run For the specific commands, see the package.json script section. Pro Tip: Cypress Studio \u00b6 You can write tests by recording your action such as typing and clicking. Read more about Cypress studio here. Please modularise and clean the test after using the recorder to make it easier to maintain. Continuous Integration - Github Actions \u00b6 We use github actions for our continuous integration. All the code being used for github actions can be seen in .github/workflows/ci.yml . This is the Continuous integration that runs for every commit on a pull request. We run a couple of things as part of our CI: Automated Testing eg pytest_py3 , integration-test-docker Automated Linting and Formatting eg frontend-check and backend-check","title":"Automated Testing and CI"},{"location":"developer/automated_testing_and_ci/#automated-testing-and-ci","text":"Automated testing help us to ensure that our code is working as expected. Continuous Integration (CI) is a process that helps us to ensure that our code is working as expected by running our automated testing on events such as pull requests and code commits.","title":"Automated Testing and CI"},{"location":"developer/automated_testing_and_ci/#automated-testing","text":"","title":"Automated Testing"},{"location":"developer/automated_testing_and_ci/#backend-pytest-unit-testing","text":"We use pytest for our tests with pytest-django as a plugin.","title":"Backend: Pytest (Unit Testing)"},{"location":"developer/automated_testing_and_ci/#running-test","text":"Go inside the container docker exec -it indeaa_django bash or docker-compose exec -it backend bash Run pytest py.test or pytest . Manual Testing Debugging You can add breakpoint() in your code and attach a terminal to the instance docker attach indeaa_django . Running only a specific test If you only want to run a specific test, use the below syntax 1 2 3 py.test course_evaluations/ # Runs all test within the folder py.test course_evaluations/test_crud.py # Runs the test in the file py.test course_evaluations/test_crud.py::test_list_view_course_evaluation # Run the specific function you want","title":"Running Test"},{"location":"developer/automated_testing_and_ci/#pytest-fixture-conftestpy","text":"You will notice that the test will use conftest.py . The syntax is a little weird at first, the fixture becomes parameters in tests that needs it. Test that uses a conftest 1 2 3 4 5 def test_list_view_course_evaluation ( api_client_with_credentials_return_user , make_course_evaluation ): api_client , user = api_client_with_credentials_return_user () course_evaluation_1 = make_course_evaluation ( coordinators = [ user ]) course_evaluation_2 = make_course_evaluation ( coordinators = [ user ]) ... api_client_with_credentials_return_user and make_course_evaluation are function that can bhe seen in conftest.py . This is accessible because of the command called @pytest.fixture . Also notice function such as make_course_evaluation . It has an interesting structure where it does a yield _make_course_evaluation . We are essentially creating a wrapper function that allows us to bind the teardown with that function.","title":"Pytest Fixture conftest.py"},{"location":"developer/automated_testing_and_ci/#why-not-just-use-the-default-django-tests","text":"The pytest ecosystem is bigger. Harder to get used to at first, but it is quite worth it because you can do cool examples like parametrised tests (checkout this link) that are more readable and maintainable.","title":"Why not just use the default Django Tests?"},{"location":"developer/automated_testing_and_ci/#frontend-cypress-e2e-testing","text":"We use Cypress for E2E testing.","title":"Frontend: Cypress (E2E Testing)"},{"location":"developer/automated_testing_and_ci/#running-the-test","text":"There are two ways to run the test. Firstly navigate to the frontend folder: Run tests via the the Cypress IDE: yarn cypress:open Run tests via the CLI: yarn cypress:run For the specific commands, see the package.json script section.","title":"Running the test."},{"location":"developer/automated_testing_and_ci/#pro-tip-cypress-studio","text":"You can write tests by recording your action such as typing and clicking. Read more about Cypress studio here. Please modularise and clean the test after using the recorder to make it easier to maintain.","title":"Pro Tip: Cypress Studio"},{"location":"developer/automated_testing_and_ci/#continuous-integration-github-actions","text":"We use github actions for our continuous integration. All the code being used for github actions can be seen in .github/workflows/ci.yml . This is the Continuous integration that runs for every commit on a pull request. We run a couple of things as part of our CI: Automated Testing eg pytest_py3 , integration-test-docker Automated Linting and Formatting eg frontend-check and backend-check","title":"Continuous Integration - Github Actions"},{"location":"developer/backup/","text":"Backup \u00b6 See create-backup.sh for the technicalities of the backup system. The gist is: we copy and compress the current volume mount for the database container. Cron Job \u00b6 We run a cron job once every month. More details about this, consult the VPS Documentation of the UWA System Health Lab.","title":"Backup"},{"location":"developer/backup/#backup","text":"See create-backup.sh for the technicalities of the backup system. The gist is: we copy and compress the current volume mount for the database container.","title":"Backup"},{"location":"developer/backup/#cron-job","text":"We run a cron job once every month. More details about this, consult the VPS Documentation of the UWA System Health Lab.","title":"Cron Job"},{"location":"developer/course_evaluation/","text":"Course Evaluation \u00b6","title":"Course Evaluation"},{"location":"developer/course_evaluation/#course-evaluation","text":"","title":"Course Evaluation"},{"location":"developer/frontend_specific_documentation/","text":"Frontend Documentation \u00b6 This contains the technical documentation for the frontend. Main Libraries to be aware of in Frontend Development \u00b6 The following libraries are to be aware of as it is extensively used in the frontend development: ReactJS NextJS : a library that handle SSR, and a more opinionated version of React that creates a lot of tooling Routing \u00b6 NextJS Routing : NextJS handling State Management \u00b6 React Context (built-in to React) that allows passing data without having a component tree Authentication To be added, an Authentication Provider will be created to handle the authentication of the user. Component System and Design \u00b6 Material UI v5 : React library that is inline with Google Material Design SSR with Material UI Note, while NextJS is a good framework, it also introduces as some extra issues that we might need to be aware of: React Hydration Error MUI Server-side Rendering API Integration \u00b6 Axios : used for making HTTP requests to the backend React-SWR (Stale While Revalidate): uses Axios to make HTTP requests to the backend and caches the response in a concise way by abstracting the usual hooks and state management Form Handling \u00b6 Formik : library to handle usual form states Yup : library to handle usual form validation Example of Using Material UI, Formik and Yup together Most often you will like to use Material UI to create a good looking form input, while using formik to handle state management and Yup with form validation. Refer to documentation for example Developer Workflow and Settings \u00b6 Vscode \u00b6 If you're using vscode, add the following configuration in .vscode/settings.json : 1 2 3 4 5 \"[javascript]\" : { \"editor.formatOnSave\" : true , \"editor.defaultFormatter\" : \"esbenp.prettier-vscode\" }, \"typescript.tsdk\" : \"frontend/node_modules/typescript/lib\" TypeScript \u00b6 Initial typescript conversion has left a lot of .ts/ .tsx files with warnings and errors that were suppressed using the @ts-ignore directive. This was mainly due to the fact the Material Dashboard was written in JavaScript and was not ported to TypeScript or no types or interfaces were provided during the initial setup process. This must be solved as soon as possible to avoid further issues and to gain from the benefits of TypeScript.","title":"Frontend Specific Documentation"},{"location":"developer/frontend_specific_documentation/#frontend-documentation","text":"This contains the technical documentation for the frontend.","title":"Frontend Documentation"},{"location":"developer/frontend_specific_documentation/#main-libraries-to-be-aware-of-in-frontend-development","text":"The following libraries are to be aware of as it is extensively used in the frontend development: ReactJS NextJS : a library that handle SSR, and a more opinionated version of React that creates a lot of tooling","title":"Main Libraries to be aware of in Frontend Development"},{"location":"developer/frontend_specific_documentation/#routing","text":"NextJS Routing : NextJS handling","title":"Routing"},{"location":"developer/frontend_specific_documentation/#state-management","text":"React Context (built-in to React) that allows passing data without having a component tree Authentication To be added, an Authentication Provider will be created to handle the authentication of the user.","title":"State Management"},{"location":"developer/frontend_specific_documentation/#component-system-and-design","text":"Material UI v5 : React library that is inline with Google Material Design SSR with Material UI Note, while NextJS is a good framework, it also introduces as some extra issues that we might need to be aware of: React Hydration Error MUI Server-side Rendering","title":"Component System and Design"},{"location":"developer/frontend_specific_documentation/#api-integration","text":"Axios : used for making HTTP requests to the backend React-SWR (Stale While Revalidate): uses Axios to make HTTP requests to the backend and caches the response in a concise way by abstracting the usual hooks and state management","title":"API Integration"},{"location":"developer/frontend_specific_documentation/#form-handling","text":"Formik : library to handle usual form states Yup : library to handle usual form validation Example of Using Material UI, Formik and Yup together Most often you will like to use Material UI to create a good looking form input, while using formik to handle state management and Yup with form validation. Refer to documentation for example","title":"Form Handling"},{"location":"developer/frontend_specific_documentation/#developer-workflow-and-settings","text":"","title":"Developer Workflow and Settings"},{"location":"developer/frontend_specific_documentation/#vscode","text":"If you're using vscode, add the following configuration in .vscode/settings.json : 1 2 3 4 5 \"[javascript]\" : { \"editor.formatOnSave\" : true , \"editor.defaultFormatter\" : \"esbenp.prettier-vscode\" }, \"typescript.tsdk\" : \"frontend/node_modules/typescript/lib\"","title":"Vscode"},{"location":"developer/frontend_specific_documentation/#typescript","text":"Initial typescript conversion has left a lot of .ts/ .tsx files with warnings and errors that were suppressed using the @ts-ignore directive. This was mainly due to the fact the Material Dashboard was written in JavaScript and was not ported to TypeScript or no types or interfaces were provided during the initial setup process. This must be solved as soon as possible to avoid further issues and to gain from the benefits of TypeScript.","title":"TypeScript"},{"location":"developer/project_structure/","text":"Project Structure \u00b6 .github \u00b6 These contains the relevant files related to github: github action automation scripts (CI scripts) issue templates pull request templates docker \u00b6 These files contains the recipes to build the docker containers for various parts of the web app. This folder also contains the environment variables that are loaded by the containers. backend \u00b6 These files contains anything related to the backend or the API. The main tech is Django with Django Rest Framework . The main files and folders (that you will need to know very well) are: - commands : Contains custom Django commands - config : This contains the main Django configurations for the application - static : This contains the static files that can be used for Django Templating engine (eg. Email and Frontend files served through Nginx as part of the backend interface) - templates : This contains the templates to be used for Django Templating engine - utils : These contains helper functions that are used in the application - pyproject.toml : Contains the dependencies of the project - manage.py : Main entrypoint for Django CLI commands - conftest.py : Pytest setup special file frontend \u00b6 These files contains anything related to the frontend. The main tech is React ( NextJS ) The main files and folders (that you will need to know very well) are: cypress : anything related to integration tests of Cypress will be here cypress.config.ts : the configuration file for Cypress components : React components pages : Page Components of NextJS package.json : Contains the dependencies of the project utils : These contains helper functions that are used in the application docs \u00b6 This contains the files related to spinning up Mkdocs .","title":"Project Structure"},{"location":"developer/project_structure/#project-structure","text":"","title":"Project Structure"},{"location":"developer/project_structure/#github","text":"These contains the relevant files related to github: github action automation scripts (CI scripts) issue templates pull request templates","title":".github"},{"location":"developer/project_structure/#docker","text":"These files contains the recipes to build the docker containers for various parts of the web app. This folder also contains the environment variables that are loaded by the containers.","title":"docker"},{"location":"developer/project_structure/#backend","text":"These files contains anything related to the backend or the API. The main tech is Django with Django Rest Framework . The main files and folders (that you will need to know very well) are: - commands : Contains custom Django commands - config : This contains the main Django configurations for the application - static : This contains the static files that can be used for Django Templating engine (eg. Email and Frontend files served through Nginx as part of the backend interface) - templates : This contains the templates to be used for Django Templating engine - utils : These contains helper functions that are used in the application - pyproject.toml : Contains the dependencies of the project - manage.py : Main entrypoint for Django CLI commands - conftest.py : Pytest setup special file","title":"backend"},{"location":"developer/project_structure/#frontend","text":"These files contains anything related to the frontend. The main tech is React ( NextJS ) The main files and folders (that you will need to know very well) are: cypress : anything related to integration tests of Cypress will be here cypress.config.ts : the configuration file for Cypress components : React components pages : Page Components of NextJS package.json : Contains the dependencies of the project utils : These contains helper functions that are used in the application","title":"frontend"},{"location":"developer/project_structure/#docs","text":"This contains the files related to spinning up Mkdocs .","title":"docs"},{"location":"developer/telemetry_and_observability/","text":"Telemetry and Observability \u00b6 Telemetry and Observability helps us developers to understand how our services are used and to improve our services. Tools used in IndEAA \u00b6 HotJar (Frontend) \u00b6 See hotjar . This tool enables us to see how the user interacts. This is qualitative data on the interaction of the user. In terms of pricing, we don't expect a huge load, so we just stick to \"free\" pricing. Anything that drops out is not much of our concern. Sentry (Frontend + Backend) \u00b6 Sentry is a tool that allows us developers to receive alerts whenever our app crashes (eg. throwing an exception). This shows us information such as where the crash occurred, the stack trace, environment, payload, as well as some meta information that can give us a full picture as to why certain errors are triggered or make us aware. See our sentry organisation to see the errors. ???+ important \"Important files and configuration in Sentry: The configuration for building frontend is in frontend/next.config.js . Note that in dryRun , we can configure to not build Sentry as part of the bundle in development mode. 1 2 3 4 5 6 Here are more configuration files with various purposes: - `sentry.properties` - selects the project for the command line of Sentry - `sentry.client.config.js` - for client-side rendering - `sentry.server.config.js` - for server-side rendering Note: For frontend, the source maps are uploaded as part of the build to Sentry. Hence, you need a `SENTRY_AUTH_TOKEN` to perform build. This can be obtained in Sentry API tokens.","title":"Telemetry and Observability"},{"location":"developer/telemetry_and_observability/#telemetry-and-observability","text":"Telemetry and Observability helps us developers to understand how our services are used and to improve our services.","title":"Telemetry and Observability"},{"location":"developer/telemetry_and_observability/#tools-used-in-indeaa","text":"","title":"Tools used in IndEAA"},{"location":"developer/telemetry_and_observability/#hotjar-frontend","text":"See hotjar . This tool enables us to see how the user interacts. This is qualitative data on the interaction of the user. In terms of pricing, we don't expect a huge load, so we just stick to \"free\" pricing. Anything that drops out is not much of our concern.","title":"HotJar (Frontend)"},{"location":"developer/telemetry_and_observability/#sentry-frontend-backend","text":"Sentry is a tool that allows us developers to receive alerts whenever our app crashes (eg. throwing an exception). This shows us information such as where the crash occurred, the stack trace, environment, payload, as well as some meta information that can give us a full picture as to why certain errors are triggered or make us aware. See our sentry organisation to see the errors. ???+ important \"Important files and configuration in Sentry: The configuration for building frontend is in frontend/next.config.js . Note that in dryRun , we can configure to not build Sentry as part of the bundle in development mode. 1 2 3 4 5 6 Here are more configuration files with various purposes: - `sentry.properties` - selects the project for the command line of Sentry - `sentry.client.config.js` - for client-side rendering - `sentry.server.config.js` - for server-side rendering Note: For frontend, the source maps are uploaded as part of the build to Sentry. Hence, you need a `SENTRY_AUTH_TOKEN` to perform build. This can be obtained in Sentry API tokens.","title":"Sentry (Frontend + Backend)"},{"location":"legal/privacy/","text":"Information we collect \u00b6 Email Login \u00b6 When you log in to our site using an email address and password, we store your email address which is used for account management only Google OAuth \u00b6 When you log in to our site using Google login, we store your Google account username, Google account id, first name, last name, and email address which are used for account management only. Hotjar \u00b6 We use Hotjar in order to better understand our users\u2019 needs and to optimize this service and experience. Hotjar is a technology service that helps us better understand our users\u2019 experience (e.g. how much time they spend on which pages, which links they choose to click, what users do and don\u2019t like, etc.) and this enables us to build and maintain our service with user feedback. Hotjar uses cookies and other technologies to collect data on our users\u2019 behavior and their devices. This includes a device's IP address (processed during your session and stored in a de-identified form), device screen size, device type (unique device identifiers), browser information, geographic location (country only), and the preferred language used to display our website. Hotjar stores this information on our behalf in a pseudonymized user profile. Hotjar is contractually forbidden to sell any of the data collected on our behalf. For further details, please see the \u2018about Hotjar\u2019 section of Hotjar\u2019s support site How We Store Information \u00b6 We do not keep information that we no longer need for the purpose it was collected, unless the law requires us to do so. It is either destroyed or de-identified as required under the Archives Act 1983. Only authorised personnel can access personal information stored by us. Security features protect it from unauthorised access. We store information in different ways, including: our document and records management systems cloud storage","title":"Privacy Policy"},{"location":"legal/privacy/#information-we-collect","text":"","title":"Information we collect"},{"location":"legal/privacy/#email-login","text":"When you log in to our site using an email address and password, we store your email address which is used for account management only","title":"Email Login"},{"location":"legal/privacy/#google-oauth","text":"When you log in to our site using Google login, we store your Google account username, Google account id, first name, last name, and email address which are used for account management only.","title":"Google OAuth"},{"location":"legal/privacy/#hotjar","text":"We use Hotjar in order to better understand our users\u2019 needs and to optimize this service and experience. Hotjar is a technology service that helps us better understand our users\u2019 experience (e.g. how much time they spend on which pages, which links they choose to click, what users do and don\u2019t like, etc.) and this enables us to build and maintain our service with user feedback. Hotjar uses cookies and other technologies to collect data on our users\u2019 behavior and their devices. This includes a device's IP address (processed during your session and stored in a de-identified form), device screen size, device type (unique device identifiers), browser information, geographic location (country only), and the preferred language used to display our website. Hotjar stores this information on our behalf in a pseudonymized user profile. Hotjar is contractually forbidden to sell any of the data collected on our behalf. For further details, please see the \u2018about Hotjar\u2019 section of Hotjar\u2019s support site","title":"Hotjar"},{"location":"legal/privacy/#how-we-store-information","text":"We do not keep information that we no longer need for the purpose it was collected, unless the law requires us to do so. It is either destroyed or de-identified as required under the Archives Act 1983. Only authorised personnel can access personal information stored by us. Security features protect it from unauthorised access. We store information in different ways, including: our document and records management systems cloud storage","title":"How We Store Information"}]}